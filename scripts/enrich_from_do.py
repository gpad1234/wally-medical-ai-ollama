#!/usr/bin/env python3
"""
Enriches sample_data/medical_ontology.ttl with official data from the
Human Disease Ontology (disease-ontology.org) REST API.

Adds to each disease individual:
  med:doid        -- the official DOID identifier
  med:synonym     -- exact synonyms (repeatable)
  med:icd10Ref    -- ICD-10-CM cross-reference(s)
  med:meshRef     -- MeSH cross-reference(s)
  rdfs:comment    -- official textual definition from DO

Usage:
  python3 scripts/enrich_from_do.py
  (re-writes sample_data/medical_ontology.ttl in-place)
"""

import json
import subprocess
import textwrap
import sys
from pathlib import Path

ROOT = Path(__file__).resolve().parent.parent
TTL_PATH = ROOT / 'sample_data' / 'medical_ontology.ttl'

# Our internal IDs → DOIDs
DISEASE_DOIDS = {
    'resp:CommonCold':      'DOID:10459',
    'resp:Influenza':       'DOID:8469',
    'resp:Pneumonia':       'DOID:552',
    'resp:Bronchitis':      'DOID:6132',
    'gi:Gastroenteritis':   'DOID:2326',
    'neuro:Migraine':       'DOID:6364',
    'cardio:Hypertension':  'DOID:10763',
}


def fetch_do_term(doid: str) -> dict:
    """Use curl to avoid macOS SSL cert issues with Python's urllib."""
    url = f'https://api.disease-ontology.org/v1/terms/{doid}'
    result = subprocess.run(
        ['curl', '-s', '--max-time', '10', url],
        capture_output=True, text=True
    )
    if result.returncode != 0 or not result.stdout.strip():
        raise RuntimeError(f'Failed to fetch {doid}: {result.stderr}')
    return json.loads(result.stdout)


def escape_ttl(s: str) -> str:
    """Escape a string for use in Turtle literals."""
    return s.replace('\\', '\\\\').replace('"', '\\"').replace('\n', ' ').strip()


def extract_xrefs(term: dict, prefix: str) -> list[str]:
    """Extract cross-references with the given prefix (e.g. 'ICD10CM', 'MESH')."""
    xrefs = term.get('xrefs', [])
    if isinstance(xrefs, dict):
        xrefs = [v for vals in xrefs.values() for v in (vals if isinstance(vals, list) else [vals])]
    return [x.get('id', '') if isinstance(x, dict) else str(x)
            for x in xrefs if (x.get('id', '') if isinstance(x, dict) else str(x)).startswith(prefix + ':')]


def fetch_all() -> dict:
    """Fetch DO data for all mapped diseases."""
    results = {}
    for local_id, doid in DISEASE_DOIDS.items():
        print(f'  Fetching {doid} ({local_id})...')
        try:
            term = fetch_do_term(doid)
            synonyms = [s['val'] for s in term.get('synonyms', []) if s.get('pred') == 'EXACT'][:4]
            icd10 = extract_xrefs(term, 'ICD10CM')[:3]
            mesh  = extract_xrefs(term, 'MESH')[:2]
            defn  = (term.get('definition') or '').strip()
            results[local_id] = {
                'doid':     doid,
                'name':     term.get('name', ''),
                'defn':     defn,
                'synonyms': synonyms,
                'icd10':    icd10,
                'mesh':     mesh,
            }
            print(f'    ✓ {term["name"]} | {len(synonyms)} synonyms | ICD10:{icd10[:1]}')
        except Exception as e:
            print(f'    ✗ Error for {doid}: {e}', file=sys.stderr)
    return results


def build_do_block(local_id: str, info: dict) -> str:
    """Return Turtle annotation triples for a disease individual."""
    lines = [f'\n### DO-enriched annotations for {local_id}']
    subj = local_id  # already in prefixed form

    lines.append(f'{subj}')
    lines.append(f'    med:doid "{escape_ttl(info["doid"])}" ;')

    if info['defn']:
        wrapped = escape_ttl(info['defn'])
        lines.append(f'    rdfs:comment "{wrapped}" ;')

    for syn in info['synonyms']:
        lines.append(f'    med:synonym "{escape_ttl(syn)}" ;')

    for icd in info['icd10']:
        code = icd.replace('ICD10CM:', '')
        lines.append(f'    med:icd10Ref "{escape_ttl(code)}" ;')

    for m in info['mesh']:
        mid = m.replace('MESH:', '')
        lines.append(f'    med:meshRef "{escape_ttl(mid)}" ;')

    # Remove trailing ' ;' on last line, replace with ' .'
    block = '\n'.join(lines)
    block = block.rstrip()
    if block.endswith(' ;'):
        block = block[:-2] + ' .'
    return block + '\n'


def inject_annotations(ttl_text: str, do_data: dict) -> str:
    """
    For each disease that already has a med:id declaration in the TTL,
    insert the DO annotation block right after its existing block ends.
    Strategy: append all DO blocks at the end of the file, before the final blank line.
    """
    # Find insertion point — just before the last section comment or EOF
    marker = '\n### ── Hierarchy'
    do_section = '\n\n# ── Disease Ontology Enrichment (auto-generated by enrich_from_do.py) ──\n'
    do_section += '# Source: https://api.disease-ontology.org/v1\n'
    do_section += '# Populated: disease-ontology.org (Human Disease Ontology, CC BY 4.0)\n\n'

    # Also add new annotation property declarations after existing ones
    prop_declarations = textwrap.dedent('''
        med:doid a owl:AnnotationProperty ;
            rdfs:label "Disease Ontology ID" ;
            rdfs:comment "Official DOID identifier from disease-ontology.org" .

        med:synonym a owl:AnnotationProperty ;
            rdfs:label "synonym" ;
            rdfs:comment "Exact synonym from the Disease Ontology" .

        med:icd10Ref a owl:AnnotationProperty ;
            rdfs:label "ICD-10-CM code" ;
            rdfs:comment "ICD-10-CM cross-reference from the Disease Ontology" .

        med:meshRef a owl:AnnotationProperty ;
            rdfs:label "MeSH reference" ;
            rdfs:comment "MeSH cross-reference from the Disease Ontology" .
    ''').strip()

    # Add DO property declarations after the existing annotation property block
    if 'med:treatType a owl:AnnotationProperty' in ttl_text:
        ttl_text = ttl_text.replace(
            'med:treatType a owl:AnnotationProperty ;',
            prop_declarations + '\n\nmed:treatType a owl:AnnotationProperty ;'
        )

    # Build the DO enrichment blocks
    for local_id, info in do_data.items():
        do_section += build_do_block(local_id, info)

    # Append at end of file
    ttl_text = ttl_text.rstrip() + '\n' + do_section
    return ttl_text


def main():
    if not TTL_PATH.exists():
        print(f'ERROR: {TTL_PATH} not found', file=sys.stderr)
        sys.exit(1)

    print('Step 1: Fetching Disease Ontology data...')
    do_data = fetch_all()

    if not do_data:
        print('No data fetched. Aborting.', file=sys.stderr)
        sys.exit(1)

    print(f'\nStep 2: Injecting {len(do_data)} disease annotations into TTL...')
    original = TTL_PATH.read_text(encoding='utf-8')

    # Idempotency check — strip existing DO enrichment block if re-running
    do_marker = '\n# ── Disease Ontology Enrichment'
    if do_marker in original:
        print('  (Replacing existing DO enrichment block)')
        original = original[:original.index(do_marker)]

    enriched = inject_annotations(original, do_data)

    TTL_PATH.write_text(enriched, encoding='utf-8')
    print(f'  ✓ Written to {TTL_PATH}')
    print(f'\nDone! {len(do_data)} diseases enriched with DOID, synonyms, ICD-10, MeSH.')


if __name__ == '__main__':
    main()
